<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CACHE on wubigo</title>
    <link>https://wubigo.com/tags/cache/</link>
    <description>Recent content in CACHE on wubigo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 05 Feb 2022 11:40:58 +0800</lastBuildDate>
    
	<atom:link href="https://wubigo.com/tags/cache/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redis消息队列和实时数据处理</title>
      <link>https://wubigo.com/post/redis-as-real-time-database/</link>
      <pubDate>Sat, 05 Feb 2022 11:40:58 +0800</pubDate>
      
      <guid>https://wubigo.com/post/redis-as-real-time-database/</guid>
      <description>REDIS Redis (Remote Dictionary Server)是一个流行的开源内存 提供高级键值抽象的键值存储。 Redis 是单线程的，它只处理一个命令 客户端在进程的主线程中一次。 不同于传统的KV 键是简单数据类型（通常是字符串）的系统，键 在 Redis 中可以用作复杂的数据类型，例如哈希、列表、 集和排序集。 此外，Redis 支持复杂的原子 对这些数据类型的操作（例如，从 一个列表，将具有给定分数的新值插入排序集等）。 Redis 抽象和高摄取速度已被证明特别重要 对于许多延迟敏感的任务很有用。 因此，Redis 已获得广泛采用，并被越来越多的人使用 生产环境中的公司.
Redis 支持高可用性和持久性。 高可用性 是通过将数据从主节点复制到 从节点并同步它们。 当一个主进程失败时，它的 对应的从属进程已准备好接管后续进程 称为故障转移。 持久性可以通过以下任一方式配置 以下两个选项：
 使用时间点快照文件 称为 RDB（Redis 数据库）
 使用名为AOF（仅附加文件）。
  注意这三种机制（AOF重写、RDB 快照和复制）依赖 fork 获取 进程内存的时间点快照并将其序列化 （而主进程继续为客户端命令提供服务）
项目简介 最近在做工业自动化(IIoT)项目，涉及到很多场景需要对一系列设备进行监控和信号处理。 该类场景对实时处理能力，系统稳定性，高可用性，容灾能力等等要求非常高。 其中几个核心的需求：
 设备数据不能丢失 实时告警(毫秒级延迟) 设备数据必须优先在边缘节点处理，边缘节点的物理服务器只有两台 每个边缘节点接入的设备上行数据量大概6万点/秒，数据包小于1K 中心需要汇聚和分析所有边缘节点的设备数据  技术现状 实时数据处理 实时数据处理是一个自 1990 年代以来一直在研究的问题 。 产生的数据量增加了，加上越来越复杂的软件解决方案 开发，需要满足这些需求出现了流式应用程序，例如 欺诈检测、网络监控和电子交易依赖于实时数据处理 确保所提供的服务被认为是正确和可靠的。 绝大多数现代应用程序使用某种数据库管理系统 处理数据。当应用程序收集或生成数据时，它会被存储和索引 它可以在以后由应用程序查询。但是，对于具有更严格 对实时数据处理的要求，这不是一个合适的方法。这是流的地方 处理开始发挥作用。流处理是在接收数据时直接处理数据。实时流 处理应用程序通常具有必须满足的某些关键要求。有低 输入和处理后的数据输出之间的延迟是实现实时的关键特征 应用。更传统的批处理方法需要以这样的方式收集数据 称为批次，其中处理只能在每个批次的最终数据块完成后开始 到达的。对于实时用例，这导致的延迟是不可接受的，因为这些实时的延迟 流应用程序最好在毫秒内。</description>
    </item>
    
    <item>
      <title>键值存储引擎基础数据结构之跳表</title>
      <link>https://wubigo.com/post/leveldb%E4%B9%8B%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Thu, 20 Feb 2020 09:58:26 +0800</pubDate>
      
      <guid>https://wubigo.com/post/leveldb%E4%B9%8B%E8%B7%B3%E8%A1%A8/</guid>
      <description>跳表介绍  Skip lists are a data structure that can be used in place of balanced trees. Skip lists use probabilistic balancing rather than strictly enforced balancing and as a result the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.
跳表是一种可以用来代替平衡树的数据结构，跳表使用概率平衡而不是严格执行的平衡， 因此，与等效树的等效算法相比，跳表中插入和删除的算法要简单得多，并且速度要快得多。
 java跳表 ConcurrentSkipList  参考 [1] Skip Lists: A Probabilistic Alternative to Balanced Trees</description>
    </item>
    
    <item>
      <title>日志：每个程序员都应该了解的实时数据统一抽象</title>
      <link>https://wubigo.com/post/log-about-real-time-datas-unifying-abstraction/</link>
      <pubDate>Fri, 15 Feb 2019 09:44:41 +0800</pubDate>
      
      <guid>https://wubigo.com/post/log-about-real-time-datas-unifying-abstraction/</guid>
      <description>在4年前加入GLODON的时候，当时我们正在从传统的CS，单体的中心数据库，私有数据中心 向分布式，混合云架构演进。我们现在构建，部署，运营分布式关系/图像/键值数据库， 分布式检索，基于HDFS和对象存储的大数据分析平台。
在这个过程中，打心里认为学到的最重要的一个简单概念：日志。有时候我们叫它预写日志， 提交日志或事务日志。日志伴随着计算机出现就一直存在，是分布式数据系统和实时应用 架构的核心。
你不会完全理解数据库，NoSQL，键值存储，复制，paxos共识，hadoop，版本控制等任务 软件系统，除非完全理解日志。然而大部分程序员其实对日志并不熟悉。本贴将带你一步步 了解日志，包括什么是日志，如何有效的使用日志，通过日志来构建数据集成，实时数据处理 等业务系统。
第一个部分：什么是日志 日志可能是最简单的存储抽象。它是一个只可追加的，完全按照时间顺序记录的数据序列。 新的记录追加到日志存储的末尾。读取的时候从左向右处理。每一条记录条目分配了一个 唯一的日志序列号。
日志的存储次序定义了时间的概念，因为左边的日志条目始终比右边的日志存储的时间更早。 日志条目唯一序列号可以看做日志条目时间戳。把这个顺序定义为时间咋一看觉得奇怪，但 这个属性很方便的和特定的物理时钟隔离开来。这个属性很快证明是分布式系统所必须的。
日志条目的内容和格式不是本贴讨论内容要重点关心的。而且我们也不能无限的追加记录， 因为存储空间的限制。我们晚点开会谈到这一点。
因此，日志和文件，数据表没有根本不同。文件是字节数组，数据表是记录数组，日志只是 一个特定的类型的文件或数据表：日志数组按时间排序。
到此，你可能奇怪，我们有啥必要讨论如此简单的东西？只可追加的日志序列到底和数据系统 在哪些方面有关联呢？答案是日志有一个特殊的目的：记录什么时间发生了什么事。对分布式 系统来说，在很多方面，这都是核心问题。
但在我们继续讨论之前，让我先澄清一个让人困惑的事情。每一个程序员应该对另一种日志定义 非常熟悉并经常使用：非结构化的错误日志或跟踪日志，这些日志由应用程序利用syslog或 log4j写到本地文件系统。这类日志我们叫做应用日志。应用日志是我要描述的日志的退化形式。 他俩最大的区别是应用日志主要是用来运维开发人员读取使用，而我描述的数据日志主用来被 程序访问。
数据库日志 我不知道数据库日志的真正起源，可能就像二分查找一样，因为太过于简单，发明者都没有意识 到这是一个发明。它最早在IBM的System R中使用，用作各种数据结构和索引在崩溃的后同步。 为了保证数据的原子性和持久性，数据库把要修改的记录在提交前先写入日志。日志记录发生了什么 ，是每个数据表或索引表的历史投影。因为日志被立即写入存储盘，被作为系统崩溃发生后进行 系统恢复有效的数据来源。
慢慢的，日志的使用范围从ACID的实现细节扩展到数据库间的数据复制机制。实践证明，这些 本地数据库数据的变更记录正是要保持远程的数据库副本同步所必需的。Oracle, MySQL和 PostgreSQL都有日志传送协议，在从库上做数据库复制。
分布式系统日志 日志解决的两个问题：变更顺序和数据分发，在分布式数据系统中更加重要。对数据变更顺序的 达成一致是这些系统设计的核心问题。
以日志为中心作为分布式系统的解决思路，源于一个简单的观察结果，我称之为状态机复制规则：
 如果两个相同的，&amp;rdquo;确定性&amp;rdquo;的程序从相同的状态启动，以相同的顺便获取 相同的输入，他俩会产生相同的输出并以相同的状态结束
 &amp;ldquo;确定性&amp;rdquo;是指程序处理不依赖于时间，不会因为任何其他的带外的输入影响其处理结果。那些 输出结果依赖线程的执行顺序，或者API调用*gettimeofday*，或其他不可重复的调用的程序 都是非&amp;rdquo;确定性&amp;rdquo;。
机器里面的数据是程序的状态的表示，任务处理完后，无论是数据留在才内存，还是在磁盘。
以相同的顺序产生的相同输入这一点提醒我们：这就是日志上场了。这是一个直觉概念： &amp;ldquo;确定性&amp;rdquo;的程序会从相同的日志产生相同的结果。
分布式应用看来一个相当直观思路就是:实现一个分布式一致性的日志，作为输入分发到多个 机器上处理相同的任务的程序。日志的目的就是排除输入流产生的所有非确定性输出，保证 每个处理输入流的程序副本保持在相同的状态。
如果你理解了这一点，关于这个规则就没有多深奥或多复杂啦，它或多或少的等于说：确实性的 处理过程是确定性的。然而，我认为它只是分布式系统设计更通用的设计工具之一。
以日志为中心的分布式设计的一个亮点，以时间戳为索引的日志成为程序副本的状态的时钟。 你可以用一个数字来描述一个程序副本：该副本处理的最近日志条目的时间戳。时间戳和日志 一起唯一的快照了副本的完整状态。
不同应用组的人描述日志的使用可能有所不同，数据库组的人经常区分物理日志和逻辑日志， 物理日志记录每行改变的内容，逻辑日志记录导致改变的SQL命令(CRUD)。
分布式系统文献经常把处理和复制划分为两大类别：状态机模式和主备模式。状态机模式 经常指双活，对输入请求做日志记录，每一个副本处理每一个请求。主备模式和状态机模式 有稍微的差别，主备模式为推举一个主节点，主节点会按顺便处理请求，并把处理结果的 状态作为日志同步到从节点。
变更日志101： 参考 [1] What every software engineer should know about real-time data&amp;rsquo;s unifying abstraction</description>
    </item>
    
    <item>
      <title>在windows上搭建Leveldb的开发环境</title>
      <link>https://wubigo.com/post/leveldb-port-in-java-dev/</link>
      <pubDate>Mon, 19 Feb 2018 18:32:37 +0800</pubDate>
      
      <guid>https://wubigo.com/post/leveldb-port-in-java-dev/</guid>
      <description>在windows上搭建Leveldb的开发环境
Leveldb使用了checkstyle
https://github.com/wubigo/leveldb/blob/master/src/checkstyle/checks.xml
&amp;lt;module name=&amp;quot;RegexpMultiline&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;format&amp;quot; value=&amp;quot;\r&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;message&amp;quot; value=&amp;quot;Line contains carriage return&amp;quot;/&amp;gt; &amp;lt;/module&amp;gt;  使用git默认设置拣出代码的时候，换行设置编译的时候会报错如下
[ERROR] src\main\java\org\iq80\leveldb\WriteOptions.java:[6] (regexp) RegexpMultiline: Line contains carriage return [ERROR] src\main\java\org\iq80\leveldb\WriteOptions.java:[7] (regexp) RegexpMultiline: Line contains carriage return  解决办法之一是调整git换行设置
git换行设置(line endings) 换行设置的3个选项:
 Checkout Windows-style, commit Unix-style  Git will convert LF to CRLF when checking out text files. When committing text files, CRLF will be converted to LF. For cross-platform projects, this is the recommended setting on Windows (&amp;ldquo;core.</description>
    </item>
    
    <item>
      <title>Redis With Spring Boot V2</title>
      <link>https://wubigo.com/post/redis-with-spring-boot-v2/</link>
      <pubDate>Thu, 28 Apr 2016 17:08:07 +0800</pubDate>
      
      <guid>https://wubigo.com/post/redis-with-spring-boot-v2/</guid>
      <description>LETTUCE VS JEDIS While Jedis is easy to use and supports a vast number of Redis features, it is not thread safe and needs connection pooling to work in a multi-threaded environment. Connection pooling comes at the cost of a physical connection per Jedis instance which increases the number of Redis connections.
Lettuce, on the other hand, is built on netty (https://netty.io/) and connection instances can be shared across multiple threads.</description>
    </item>
    
    <item>
      <title>Redis Notes</title>
      <link>https://wubigo.com/post/redis-notes/</link>
      <pubDate>Thu, 02 Aug 2012 07:34:07 +0800</pubDate>
      
      <guid>https://wubigo.com/post/redis-notes/</guid>
      <description>系统配置 /etc/sysctl.conf
vm.swappiness = 1 vm.overcommit_memory = 1  改变数据目录 sudo install -o redis -g redis -d /mnt/redis-data &amp;gt; config get dir 1) &amp;quot;dir&amp;quot; 2) &amp;quot;/mnt/redis-data&amp;quot;  /lib/systemd/system/redis-server.service
[Service] ReadWriteDirectories=-/mnt/redis-data  pidfile NOT FOUND FROM SYSTEMD /etc/redis/redis.conf
pidfile /var/run/redis/redis-server.pid  /lib/systemd/system/redis-server.service
PIDFile=/run/redis/redis-server.pid  删除消费组 XGROUP DESTROY STREAM:TEST STRRAM:TEST:GROUP  Redis latency problems troubleshooting  Make sure you are not running slow commands that are blocking the server. Use the Redis Slow Log feature to check this.</description>
    </item>
    
  </channel>
</rss>